const Prompt = require('../models/Prompt');
const Conversation = require('../models/Conversation');
const User = require('../models/User');
const axios = require('axios');
const { GoogleGenAI } = require('@google/genai');


// Initialize Gemini SDK lazily
let genAI;
const getGeminiClient = () => {
    if (!genAI) {
        if (!process.env.GEMINI_API_KEY) {
            throw new Error('GEMINI_API_KEY is missing');
        }
        genAI = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });
    }
    return genAI;
};

const ensureCredits = async (userId, amount) => {
    if (!userId) {
        return null;
    }
    await User.updateOne(
        { _id: userId, credits: { $exists: false } },
        { $set: { credits: 10000 } }
    );
    const user = await User.findById(userId).select('credits');
    if (!user || typeof user.credits !== 'number' || user.credits < amount) {
        return null;
    }
    return user;
};

const debitCredits = async (userId, amount) => {
    if (!userId) {
        return null;
    }
    await User.updateOne(
        { _id: userId, credits: { $exists: false } },
        { $set: { credits: 10000 } }
    );
    return User.findOneAndUpdate(
        { _id: userId, credits: { $gte: amount } },
        { $inc: { credits: -amount } },
        { new: true }
    );
};

const refundCredits = async (userId, amount) => {
    if (!userId) {
        return null;
    }
    return User.findByIdAndUpdate(
        userId,
        { $inc: { credits: amount } },
        { new: true }
    );
};

exports.createImage = async (req, res) => {
    try {
        const { prompt, negativePrompt, style, conversationId } = req.body;
        const userId = req.user?.id; // Optional

        if (!userId) {
            return res.status(401).json({ success: false, message: 'Login required to use credits' });
        }

        const updatedUser = await debitCredits(userId, 50);
        if (!updatedUser) {
            return res.status(402).json({ success: false, message: 'Insufficient credits' });
        }

        if (!process.env.GEMINI_API_KEY) {
            console.warn('GEMINI_API_KEY missing. Using Pollinations.ai as fallback.');
        }

        let aiData;
        let finalPrompt = prompt;

        // 1. Enhance prompt with Gemini
        if (process.env.GEMINI_API_KEY) {
            try {
                console.log('Enhancing prompt with Gemini...');
                const client = getGeminiClient();

                const enhancePrompt = `Act as an expert AI Art prompt engineer. 
User Input: "${prompt}"
Style: "${style || 'Realistic'}"

Return ONLY a JSON object with:
- "enhancedPrompt": a detailed, optimized prompt (max 200 chars) for image generation
- "caption": a short, creative 1-sentence caption

JSON:`;

                const enhanceResponse = await client.models.generateContent({
                    model: "gemini-2.0-flash",
                    contents: enhancePrompt,
                });

                const textPart = enhanceResponse.candidates?.[0]?.content?.parts?.find(part => part.text);
                const text = textPart?.text || '';

                try {
                    const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();
                    aiData = JSON.parse(cleanText);
                    finalPrompt = aiData.enhancedPrompt || prompt;
                } catch (e) {
                    console.error('Failed to parse Gemini response, using raw prompt:', e.message);
                    aiData = { enhancedPrompt: prompt, caption: "Generated by AI" };
                }
            } catch (err) {
                console.error('Gemini enhancement failed, using raw prompt:', err.message);
                aiData = { enhancedPrompt: prompt, caption: "Generated by AI" };
            }
        } else {
            aiData = { enhancedPrompt: prompt, caption: "Generated by AI (Free Mode)" };
        }

        // 2. Generate Image with Gemini
        let imageUrl;

        if (process.env.GEMINI_API_KEY) {
            try {
                console.log('Generating image with Gemini...');
                const client = getGeminiClient();

                const geminiResponse = await client.models.generateContent({
                    model: "gemini-2.5-flash-image",
                    contents: `${finalPrompt}, ${style || 'Realistic'}, high quality, 8k`,
                });

                const part = geminiResponse.candidates[0].content.parts.find(p => p.inlineData);

                if (part) {
                    imageUrl = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
                } else {
                    throw new Error('No image data returned from Gemini');
                }
            } catch (err) {
                console.error('Gemini generation failed, falling back to Pollinations:', err.message);
                const encodedPrompt = encodeURIComponent(`${finalPrompt}, ${style || 'Realistic'}, high quality, 8k`);
                imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?nologo=true&private=true`;
            }
        } else {
            console.log('Using Pollinations.ai for image generation (Free Mode)...');
            const encodedPrompt = encodeURIComponent(`${finalPrompt}, ${style || 'Realistic'}, high quality, 8k`);
            imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?nologo=true&private=true`;
        }

        const newPromptData = {
            prompt,
            enhancedPrompt: finalPrompt,
            aiResponse: aiData.caption,
            negativePrompt,
            style: style || 'Realistic',
            imageUrl: imageUrl,
        };

        if (userId) {
            console.log('Saving to DB for user:', userId);
            newPromptData.user = userId;

            let convId = conversationId;
            if (!convId) {
                console.log('Creating new conversation...');
                const newConv = new Conversation({
                    title: prompt.substring(0, 30) + (prompt.length > 30 ? '...' : ''),
                    user: userId
                });
                const savedConv = await newConv.save();
                convId = savedConv._id;
                console.log('New conversation created:', convId);
            } else {
                await Conversation.findByIdAndUpdate(convId, { updatedAt: Date.now() });
            }

            newPromptData.conversation = convId;
            const newPrompt = new Prompt(newPromptData);
            await newPrompt.save();
            console.log('Prompt saved successfully');
            res.status(201).json({ success: true, data: newPrompt, conversationId: convId, credits: updatedUser.credits });
        } else {
            console.log('No userId found, not saving to DB');
            res.status(201).json({ success: true, data: newPromptData, credits: updatedUser.credits });
        }
    } catch (error) {
        console.error('Error creating image:', error.message);
        res.status(500).json({ success: false, error: 'Server Error', details: error.message });
    }
};

exports.editImage = async (req, res) => {
    try {
        const { prompt, style, conversationId } = req.body;
        const userId = req.user?.id;
        const uploadedImage = req.file;
        let debitedUser = null;

        if (!userId) {
            return res.status(401).json({ success: false, message: 'Login required to use credits' });
        }

        if (!prompt) {
            return res.status(400).json({ success: false, message: 'Prompt is required' });
        }

        if (!uploadedImage) {
            return res.status(400).json({ success: false, message: 'Image file is required' });
        }

        if (!process.env.GEMINI_API_KEY) {
            return res.status(500).json({ success: false, message: 'GEMINI_API_KEY is missing' });
        }

        const creditCheck = await ensureCredits(userId, 50);
        if (!creditCheck) {
            return res.status(402).json({ success: false, message: 'Insufficient credits' });
        }

        debitedUser = await debitCredits(userId, 50);
        if (!debitedUser) {
            return res.status(402).json({ success: false, message: 'Insufficient credits' });
        }

        const client = getGeminiClient();
        const imagePart = {
            inlineData: {
                data: uploadedImage.buffer.toString('base64'),
                mimeType: uploadedImage.mimetype,
            },
        };

        const editPrompt = `
      You are an expert AI image editor. You are given an input image and a user instruction.
      User instruction: "${prompt}"
      Style: "${style || 'Realistic'}"

      Task 1: Describe the key elements of the image in one short sentence.
      Task 2: Produce a concise, detailed text-to-image prompt (max 200 chars) that applies the user's requested changes while preserving the core scene.

      Return ONLY a JSON object like this:
      {
        "enhancedPrompt": "...",
        "caption": "..."
      }
    `;

        const analysisResponse = await client.models.generateContent({
            model: "gemini-2.0-flash",
            contents: [
                {
                    role: "user",
                    parts: [{ text: editPrompt }, imagePart],
                },
            ],
        });

        const textPart = analysisResponse.candidates?.[0]?.content?.parts?.find((part) => part.text);
        const text = textPart?.text || '';

        let aiData;
        try {
            const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();
            aiData = JSON.parse(cleanText);
        } catch (e) {
            aiData = { enhancedPrompt: prompt, caption: "Generated by AI" };
        }

        const finalPrompt = aiData.enhancedPrompt || prompt;
        let imageUrl;

        try {
            const imageResponse = await client.models.generateContent({
                model: "gemini-2.5-flash-image",
                contents: `${finalPrompt}, ${style || 'Realistic'}, high quality, 8k`,
            });

            const imagePart = imageResponse.candidates?.[0]?.content?.parts?.find((part) => part.inlineData);

            if (imagePart?.inlineData) {
                imageUrl = `data:${imagePart.inlineData.mimeType};base64,${imagePart.inlineData.data}`;
            } else {
                throw new Error('No image data returned from Gemini');
            }
        } catch (err) {
            console.error('Gemini edit generation failed, falling back to Pollinations:', err.message);
            const encodedPrompt = encodeURIComponent(`${finalPrompt}, ${style || 'Realistic'}, high quality, 8k`);
            imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?nologo=true&private=true`;
        }

        const newPromptData = {
            prompt,
            enhancedPrompt: finalPrompt,
            aiResponse: aiData.caption,
            style: style || 'Realistic',
            imageUrl,
        };

        if (userId) {
            let convId = conversationId;
            if (!convId) {
                const newConv = new Conversation({
                    title: prompt.substring(0, 30) + (prompt.length > 30 ? '...' : ''),
                    user: userId,
                });
                const savedConv = await newConv.save();
                convId = savedConv._id;
            } else {
                await Conversation.findByIdAndUpdate(convId, { updatedAt: Date.now() });
            }

            newPromptData.user = userId;
            newPromptData.conversation = convId;
            const newPrompt = new Prompt(newPromptData);
            await newPrompt.save();
            return res.status(201).json({ success: true, data: newPrompt, conversationId: convId, credits: debitedUser.credits });
        }

        return res.status(201).json({ success: true, data: newPromptData, credits: debitedUser.credits });
    } catch (error) {
        console.error('Error editing image:', error.message);
        if (req.user?.id) {
            try {
                const refunded = await refundCredits(req.user.id, 50);
                if (refunded) {
                    return res.status(500).json({
                        success: false,
                        error: 'Server Error',
                        details: error.message,
                        credits: refunded.credits
                    });
                }
            } catch (refundError) {
                console.error('Failed to refund credits:', refundError.message);
            }
        }
        return res.status(500).json({ success: false, error: 'Server Error', details: error.message });
    }
};

exports.getPrompts = async (req, res) => {
    try {
        const prompts = await Prompt.find().sort({ createdAt: -1 });
        res.status(200).json({ success: true, data: prompts });
    } catch (error) {
        console.error('Error fetching prompts:', error);
        res.status(500).json({ success: false, error: 'Server Error' });
    }
};

exports.generateText = async (req, res) => {
    try {
        const { prompt, style, conversationId } = req.body;
        if (!prompt) {
            return res.status(400).json({ success: false, message: 'Prompt is required' });
        }

        const userId = req.user?.id;
        if (!userId) {
            return res.status(401).json({ success: false, message: 'Login required to use credits' });
        }

        const updatedUser = await debitCredits(userId, 50);
        if (!updatedUser) {
            return res.status(402).json({ success: false, message: 'Insufficient credits' });
        }

        let text;
        if (process.env.GEMINI_API_KEY) {
            try {
                console.log('Generating text with Gemini...');
                const client = getGeminiClient();

                const textPrompt = `Act as a creative assistant. Style: "${style || 'Realistic'}".
User request: "${prompt}"

Write a concise, vivid 2-3 sentence response describing the scene or answering the request.`;

                const textResponse = await client.models.generateContent({
                    model: "gemini-2.0-flash",
                    contents: textPrompt,
                });

                const textPart = textResponse.candidates?.[0]?.content?.parts?.find(part => part.text);
                text = textPart?.text || 'Generated by AI';
            } catch (err) {
                console.error('Gemini text generation failed, falling back to Pollinations:', err.message);
                const pollResponse = await axios.get(`https://text.pollinations.ai/${encodeURIComponent(prompt)}?model=openai`);
                text = pollResponse.data;
            }
        } else {
            console.log('Using Pollinations.ai for text generation (Free Mode)...');
            const pollResponse = await axios.get(`https://text.pollinations.ai/${encodeURIComponent(prompt)}?model=openai`);
            text = pollResponse.data;
        }

        const newPromptData = {
            prompt,
            aiResponse: text.trim(),
            style: style || 'Realistic',
        };

        if (userId) {
            console.log('Saving text to DB for user:', userId);
            newPromptData.user = userId;

            let convId = conversationId;
            if (!convId) {
                console.log('Creating new conversation for text...');
                const newConv = new Conversation({
                    title: prompt.substring(0, 30) + (prompt.length > 30 ? '...' : ''),
                    user: userId
                });
                const savedConv = await newConv.save();
                convId = savedConv._id;
                console.log('New conversation created:', convId);
            } else {
                await Conversation.findByIdAndUpdate(convId, { updatedAt: Date.now() });
            }

            newPromptData.conversation = convId;
            const newPrompt = new Prompt(newPromptData);
            await newPrompt.save();
            console.log('Text prompt saved successfully');
            res.status(200).json({ success: true, data: newPrompt, conversationId: convId, credits: updatedUser.credits });
        } else {
            console.log('No user found for text, not saving to DB');
            res.status(200).json({ success: true, data: { prompt, aiResponse: text.trim() }, credits: updatedUser.credits });
        }
    } catch (error) {
        console.error('Error generating text:', error.message);
        res.status(500).json({ success: false, error: 'Server Error', details: error.message });
    }
};

exports.getUserPrompts = async (req, res) => {
    try {
        const prompts = await Prompt.find({ user: req.user.id }).sort({ createdAt: -1 });
        res.status(200).json({ success: true, data: prompts });
    } catch (error) {
        console.error('Error fetching user prompts:', error);
        res.status(500).json({ success: false, error: 'Server Error' });
    }
};

exports.getConversations = async (req, res) => {
    try {
        const conversations = await Conversation.find({ user: req.user.id }).sort({ updatedAt: -1 });
        res.status(200).json({ success: true, data: conversations });
    } catch (error) {
        console.error('Error fetching conversations:', error);
        res.status(500).json({ success: false, error: 'Server Error' });
    }
};

exports.getConversationPrompts = async (req, res) => {
    try {
        const prompts = await Prompt.find({ conversation: req.params.id }).sort({ createdAt: 1 });
        res.status(200).json({ success: true, data: prompts });
    } catch (error) {
        console.error('Error fetching conversation prompts:', error);
        res.status(500).json({ success: false, error: 'Server Error' });
    }
};
